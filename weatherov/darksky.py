""" Download, analyze and plot weather data using data from DarkSky API

See documentation of API here: https://darksky.net/dev/docs
Here, a higher level set of functions is provided for easier handling of
data from the API.

Requires an account at Dark Sky, which provides an API key, except when
using data that has been already downloaded from DarkSky separately. Note that
the free version of the API is limited to 1000 requests per day.

Functions
--------

Summary of functions (see examples and help(function) for implementation):

To produce complete RAW data (dictionary corresponding to DarkSky .json file),
use the following functions:
- `generate_url` and copy-paste the link into a browser (returns url link)
- `download_day` to get the raw data from the internet (returns dict of data)
- `load_day` to get the raw data from downloaded files (returns dict of data)

To produce FORMATTED data for analysis and plotting, use the following:
- `weather_pt`  (returns a dict of values -- data at specific time)
- `weather_day` (returns a dict of lists -- hourly data)
- `weather_days` (returns a dict of lists -- hourly data)

To download a bunch of data from the internet and save in a file:
- `download_days` (saves RAW data in .json format in a folder, it is a threaded
version of download_day)
- `download_missing_days` (to run after download_days if some days have failed)
- the above function uses `check_missing_days`, which can also be used as a 
standalone function

To plot the data:
- `weather_plot`, with formatted data from `weather_day` or `weather_days`

Notes
-----
- If one gets the error `KeyError: 'hourly'`, it's likely that the data is not 
downloaded correctly or inexistent. Check that the api_key is correct and/or
test the download URL generated by `generate_url` in a browser.

- More data might be available compared to the ones returned by the functions
used here, see e.g. the raw dictionary returned by functions like load_day.
"""

# TODO: move from threading to concurrent futures
# TODO: error or warning if someone tries to create a folder called 'internet'


import requests
from datetime import datetime, timedelta

import threading
import time
import json
from pathlib import Path

import matplotlib.pyplot as plt
# the two lines below are used to avoid pandas / matplotlib complaining
from pandas.plotting import register_matplotlib_converters
register_matplotlib_converters()


# ======================== info on how data is formatted =====================


in_names = ['time', 'temperature', 'humidity', 'pressure',
            'windSpeed', 'windGust', 'windBearing', 
            'precipIntensity', 'visibility', 'cloudCover', 'ozone']

out_names = ['t', 'T', 'RH', 'P',
             'wind speed', 'wind gust', 'wind direction',
             'rain', 'visibility', 'clouds', 'ozone']


# ================================ functions =================================


def generate_url(location, date='now', api_key=''):
    """
    Formats URL for request to DarkSky

    INPUTS
    - location is a tuple (lon, lat)
    - date is either 'now' (default), or a datetime (datetime.datetime)
    - api_key (string) is the API key for accessing DarkSky.net data

    OUTPUTS
    - url of data (string), can be accessed directly in a browser (json)
    """

    (lat, lon) = location
    coord = f'{lat},{lon}'

    website = 'https://api.darksky.net/forecast/'

    base_url = website + api_key + '/' + coord
    units = 'ca'
    # (ca units is SI but ensures that wind is in km/h)

    if date == 'now':
        url = base_url + '?units=' + units
    else:
        t_unix = int(datetime.timestamp(date))
        url = base_url + f',{t_unix}' + '?units=' + units

    return url


def generate_filename(location, date):
    (lat, lon) = location
    coord = f'{lat},{lon}'
    year = date.year
    month = date.month
    day = date.day
    filename = 'DarkSky_' + coord + f',{year:04d}-{month:02d}-{day:02d}.json'
    return filename


def download_day(location, date='now', api_key='', save=False, folder=''):
    """
    Downloads single weather point (typically, will return a whole day,
    including forecast if date is in the current day). It saves the data in a
    json file if save is True, in the folder (current folder by default)

    There is an option to not save the data, because the function is also used
    by weather_pt() and weather_day() in a mode where it transfers the data
    to these functions for immediate usage without saving.

    INPUTS
    - location is a tuple (lon, lat)
    - date is either 'now' (default), or a datetime (datetime.datetime)
    - api_key (string) is the API key for accessing DarkSky.net data
    - save is boolean
    - folder is a string representing a path for saving

    OUTPUTS
    - dictionary of raw data corresponding to the DarkSky .json file
    """

    url = generate_url(location, date, api_key)
    
    date_str = date if date == 'now' else datetime.strftime(date, '%x')
    
    try:
        data = requests.get(url).json()
    except Exception:
        print(f'Download error for {date_str}. Please try again.')
        return None

    if get_hourly_data(data) is None:
        print(f'Warning: No Hourly Data on {date_str}.')

    if save is True:

        if date == 'now': date = datetime.now()  # Warning -- date changed here

        filename = generate_filename(location, date)
        
        foldername = Path(folder)
        foldername.mkdir(parents=True, exist_ok=True)

        savefile = foldername / filename

        with open(savefile, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=4)

    return data


def download_days(location, date_start, date_end, api_key='', folder=''):
    """
    Downloads weather data (day-by-day) from DarkSky between selected dates.
    Uses threading on the function dowload_day().

    INPUTS
    Same as download_day except that dates have to be datetimes (not 'now')
    and there is no `save` option (data is always saved in a file here).

    OUTPUTS
    None
    """
    delta_t = date_end - date_start
    ndays = delta_t.days + 1  # number of days to load

    threads = []
    tstart = time.time()
    print(f'Loading started in folder {folder}')

    for day in range(ndays):
        date = date_start + timedelta(days=day)
        arguments = (location, date, api_key, True, folder)
        thread = threading.Thread(target=download_day, args=arguments)
        threads.append(thread)

    for thread in threads:
        thread.start()

    for thread in threads:
        thread.join()

    tend = time.time()
    total_time = tend - tstart

    print(f'Loading finished in {total_time} seconds.')
    
    # Check that all requested files have been downloadedand download missing
    download_missing_days(location, date_start, date_end, api_key, folder)

    return


def check_missing_days(location, date_start, date_end, folder=''):
    """Check for missing days between two dates in downloaded data"""
    
    delta_t = date_end - date_start
    ndays = delta_t.days + 1  # number of days to load
    
    missing_days = []
    
    for day in range(ndays):
        
        date = date_start + timedelta(days=day)     
        file = Path(folder) / generate_filename(location, date)
        
        if file.exists() is False:
            missing_days.append(date)
            
    if len(missing_days) == 0:
        print('No missing days found.')
    else:
        n_miss = len(missing_days)
        print(f'{n_miss} missing days found.')
        
    return missing_days


def get_hourly_data(data):
    """Check if there is hourly data in RAW darksky data, if yes return it."""
    try:
        data_hourly = data['hourly']['data']
    except KeyError:
        return None
    else:
        return data_hourly


def download_missing_days(location, date_start, date_end, api_key='', folder=''):
    """
    Check if there are missing days between two dates and download them.
    
    Inputs / Outputs are the same as download_days()
    """
    tstart = time.time()
    
    # Check missing days -----------------------------------------------------
    
    missing_days = check_missing_days(location, date_start, date_end, folder)
    
    if len(missing_days) > 0:

        threads = []
        
        print(f'Loading missing days in folder {folder}')
    
        for date in missing_days:
            arguments = (location, date, api_key, True, folder)
            thread = threading.Thread(target=download_day, args=arguments)
            threads.append(thread)
    
        for thread in threads:
            thread.start()
    
        for thread in threads:
            thread.join()
    
        tend = time.time()
        total_time = tend - tstart
    
        print(f'Loading finished in {total_time} seconds.')

    return


def load_day(location, date='now', folder=''):
    """
    Loads weather data (single whole day) that has been downloaded in a folder
    using download_day or download_days.

    INPUTS
    - location is a tuple (lon, lat)
    - date is either 'now' (default), or a datetime (datetime.datetime)
    - folder is a string representing a path where data is loaded from

    OUTPUTS
    - dictionary of raw data corresponding to the DarkSky .json file
    """

    if date == 'now': date = datetime.now()  # Warning -- date changed here

    (lat, lon) = location
    coord = f'{lat},{lon}'
    year = date.year
    month = date.month
    day = date.day

    filename = 'DarkSky_' + coord + f',{year:04d}-{month:02d}-{day:02d}.json'

    foldername = Path(folder)

    file = foldername / filename

    with open(file, 'r') as f:
        data = json.load(f)

    return data


def weather_pt(location, date='now', api_key=''):
    """
    Loads weather condition at a specific time, from the internet (DarkSky)

    INPUTS
    - location is a tuple (lon, lat)
    - date is either 'now' (default), or a datetime (datetime.datetime)
    - api_key (string) is the API key for accessing DarkSky.net data

    OUTPUTS
    - dictionary of formatted data {'t': t, 'T': T, 'RH': RH ...} where T, RH
    etc. are single numbers correspond to the weather conditions at time t.
    """

    data_all = download_day(location, date, api_key)
    data = data_all['currently']
    data_pts = _data_to_pts(data)

    return data_pts


def weather_day(location, date, api_key='', source='internet'):
    """
    Loads hourly weather for a specific day (date in datetime format).

    INPUTS
    - location is a tuple (lon, lat)
    - date is either 'now' (default), or a datetime (datetime.datetime)
    - api_key (string) is the API key for accessing DarkSky.net data
    - source is either 'internet' (requests data from DarkSky.net) or a folder

    OUTPUTS
    - dictionary of formatted data {'t': ts, 'T': Ts, 'RH': RH ...} where ts,
    Ts, etc. are lists (length 24) corresponding to hourly data
    """

    if source == 'internet':
        data_all = download_day(location, date, api_key)
    else:
        data_all = load_day(location, date, source)

    data_hourly = get_hourly_data(data_all)
    
    if data_hourly is None:
        date_str = datetime.strftime(date, '%x')
        print(f'Warning: No hourly data on {date_str}. Returning None.')
        return None

    data_out = {}
    for outname in out_names:  # affect empty list to every data type 
        data_out[outname] = []   
    
    for data in data_hourly:  # loops over hours of that day

        data_pts = _data_to_pts(data)

        for outname in out_names:
            data_out[outname].append(data_pts[outname])

    return data_out


def weather_days(location, date_start, ndays, api_key='', source='internet'):
    """
    Loads hourly weather for several days (number of days is ndays)

    INPUTS
    - location is a tuple (lon, lat)
    - date_start is a datetime (datetime.datetime)
    - ndays is an int (number of days)
    - api_key (string) is the API key for accessing DarkSky.net data
    - source is either 'internet' (requests data from DarkSky.net) or a folder

    OUTPUTS
    - dictionary of formatted data {'t': ts, 'T': Ts, 'RH': RH ...} where ts,
    Ts, etc. are lists (length ndays*24) corresponding to hourly data
    """

    data_out = {}
    for outname in out_names:  # affect empty list to every data type 
        data_out[outname] = []
            
    for day in range(ndays):

        date = date_start + timedelta(days=day)
        data = weather_day(location, date, api_key, source)

        if data is None:
            pass
        else:
            for outname in out_names:
                data_out[outname] += data[outname]
    
    return data_out


def _data_to_pts(data):
    """
    Converts raw data into usable data in weatherov (dict of names and values)
    Used by weather_day and weather_pt
    """
    
    def formatdata(name):
        try:
            val = data[name]
        except KeyError:
            val = None
        return val

    data_out = []
    
    for dataname in in_names:
        
        if dataname == 'time':
            data_time = data['time']
            x = datetime.fromtimestamp(data_time)
        else:
            x = formatdata(dataname)
        
        # For humidity, put the value initially in 0-1 in 0-100%
        if dataname == 'humidity' and x is not None:
            x = 100*x
            
        data_out.append(x)
    
    return dict(zip(out_names, data_out))


def weather_plot(data, title=None):
    """
    Plots hourly data of temperature, humidity and wind on a single graph.

    INPUT
    - formatted data (dict from weather_pt, weather_day, or weather_days)
    - optional title of graph
    
    OUTPUT
    figure and axes: fig, axa, axb (axa is a tuple of main ax, axb secondary)
    """
    
    t = data['t']
    T = data['T']
    RH = data['RH']
    w = data['wind speed']
    wmax = data['wind gust']
    wdir = data['wind direction']
    rain = data['rain']
    clouds = data['clouds']
    
    T_color = '#c34a47'
    RH_color = '#c4c4cc'
    w_color = '#2d5e46'
    dir_color = '#adc3b8'
    rain_color = '#a2c0d0'
    cloud_color = '#3c5a6a'
    
    fig, axs = plt.subplots(1, 3, figsize=(12, 3))   
    ax0a, ax1a, ax2a = axs
    

    # SUBPLOT 0 -- Temperature and RH ----------------------------------------

    ax0b = ax0a.twinx()  # share same x axis for T and RH
       
    ax0b.bar(t, RH, width=0.042, color=RH_color)
    ax0a.plot(t, T, '.-', color=T_color)
    
    ax0a.set_ylabel('T (°C)', color=T_color)
    ax0a.tick_params(axis='y', labelcolor=T_color)

    ax0b.set_ylabel('%RH', color=RH_color)
    ax0b.tick_params(axis='y', labelcolor=RH_color)

    ax0a.set_zorder(1)  # to put fist axis in front
    ax0a.patch.set_visible(False)  # to see second axis behind

    ax0b.set_ylim(0, 100)
    
    
    # SUBPLOT 1 -- Wind ------------------------------------------------------
    
    ax1b = ax1a.twinx()  # same for wind speed and wind direction

    ax1a.plot(t, w, '.-', color=w_color)
    ax1a.plot(t, wmax, '--', color=w_color)
    ax1b.bar(t, wdir, width=0.042, color=dir_color)

    ax1a.set_ylabel('Wind speed (km/h)', color=w_color)
    ax1a.tick_params(axis='y', labelcolor=w_color)

    ax1b.set_ylabel('Wind direction', color=dir_color)
    ax1b.tick_params(axis='y', labelcolor=dir_color)

    ax1b.set_ylim(0, 360)
    ax1b.set_yticks([0, 45, 90, 135, 180, 225, 270, 315, 360])
    ax1b.set_yticklabels(['N', 'NE', 'E', 'SE', 'S', 'SW', 'W', 'NW', 'N'])
       
    ax1a.set_zorder(1)  # to put fist axis in front
    ax1a.patch.set_visible(False)  # to see second axis behind
    
    
    # SUBPLOT 2 -- Rain and Clouds -------------------------------------------
    
    ax2b = ax2a.twinx()  # same for wind speed and wind direction

    ax2b.bar(t, rain, width=0.042, color=rain_color)
    ax2a.plot(t, clouds, '.:', color=cloud_color)
    
    ax2a.set_ylabel('Cloud cover', color=cloud_color)
    ax2a.tick_params(axis='y', labelcolor=cloud_color)

    ax2b.set_ylabel('Rain', color=rain_color)
    ax2b.tick_params(axis='y', labelcolor=rain_color)

    ax2a.set_ylim(0, 1)
    

    # finalize figure --------------------------------------------------------

    axa = (ax0a, ax1a, ax2a)
    axb = (ax0b, ax1b, ax2b)

    
    tmin = min(t)
    tmax = max(t)
    dt = (tmax-tmin)/60

    for ax in axa:
        ax.set_xlim((tmin, tmax+dt)) # the +dt is for the last timestamp to appear
    
    if title is not None:
        fig.suptitle(title)

    fig.autofmt_xdate()
    fig.tight_layout()

    fig.show()
    
    return fig, axa, axb

